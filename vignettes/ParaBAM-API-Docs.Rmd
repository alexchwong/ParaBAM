---
title: "ParaBAM-API-Docs"
output:     
  rmarkdown::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{ParaBAM-API-Docs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Setting up a new R package to include ParaBAM

There are several simple steps required to set up a new R package that uses
ParaBAM.

## Making a new Rcpp package

Please follow the steps in the Rcpp vignette to set up a new package that uses 
Rcpp. This vignette can be accessed by typing the following in the console:

```r
vignette("Rcpp-package", package = "Rcpp")
```


## Dependencies

Now that you have made a new package, you will need to make several tweaks to
utilise ParaBAM. ParaBAM uses zlib to decompress BAM files. So you must link
your source code to Rcpp, zlibbioc as well as ParaBAM itself.

Add the following to the DESCRIPTION file:


```
Imports: Rcpp (>= 1.0.5)
LinkingTo: Rcpp, zlibbioc, ParaBAM
```

## Makefile

To ensure that your new package will compile and dynamically link to the correct
libraries, you need a makefile that instructs the compiler to do so.

First, create a new file under the "src" subdirectory and name it "Makevars".
Add the following code to this file:

```cmake
PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS)
PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS)
```

For windows installations, you will need a second file in the "src" folder. Make
a new file called "Makevars.win" and add the following:

```cmake
PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) 
PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS)

ZLIB_CFLAGS+=$(shell echo 'zlibbioc::pkgconfig("PKG_CFLAGS")'|\
    "${R_HOME}/bin/R" --vanilla --slave)
PKG_LIBS+=$(shell echo 'zlibbioc::pkgconfig("PKG_LIBS_shared")' |\
    "${R_HOME}/bin/R" --vanilla --slave)
```

This will ensure that the zlib libraries are linked correctly to Windows systems

## OpenMP compatibility

Windows and Linux systems should support OpenMP natively. MacOS, however, does
not. In order to set up OpenMP for MacOS, we recommend following this
[guide](https://mac.r-project.org/openmp/). As can be seen, OpenMP for MacOS
will continue to be a difficult issue. We recommend writing C++ code that
is compatible for both OpenMP and non-OpenMP systems. For non-OpenMP systems,
multi-threading can still be implemented via \code{BiocParallel::MulticoreParam}
but the session memory will be multiplied over the number of cores used.

In C++ code, to check whether OpenMP is installed in a system, use the #ifdef
and #ifndef directives. An example below:

```cpp
#ifdef _OPENMP
  // Add code here for programs compiled with OpenMP
#else
  // Add code here for programs not using OpenMP
#endif
```

# Writing a simple program based on ParaBAM

In this vignette, we will demonstrate how to use ParaBAM to open a BAM file and
read its contents in a multi-threaded way. In essence, we will explain 
step-by-step how the code works in the ParaBAMExample package included with this
package.

To install the ParaBAMExample package, refer to the following:

```r
?install_ParaBAM_example
```

## Headers and Includes

To add the ParaBAM header files into your source code (here we refer to 
"main.cpp") in ParaBAMExample package, start with the following:

```cpp
// [[Rcpp::depends(ParaBAM)]]
#include <ParaBAM.hpp>

#include "Rcpp.h"
using namespace Rcpp;
```

The line #include "Rcpp.h" is probably redundant as ParaBAM.hpp already contains
this line, but we include it here for completeness.

## Adding progress bar functionality

ParaBAMExample also demonstrates how to use a progress bar to visualise the
progress in reading the BAM file. To utilise this, we use the RcppProgress
package from CRAN which provides the requisite header files for these functions.

Be sure to add "RcppProgress" in the "LinkingTo:" line in the DESCRIPTION file:

```
LinkingTo: Rcpp, zlibbioc, ParaBAM, RcppProgress
```

Also, add the following to your source code:

```cpp
// [[Rcpp::depends(RcppProgress)]]
#include <progress.hpp>
```

## Creating the "idxstats" example function

In this vignette we will reproduce the "idxstats" function from samtools. This
function prints out all the chromosomes, their lengths, as well as the number of
reads mapped to each chromosome. You can read about this function 
[here](http://www.htslib.org/doc/samtools-idxstats.html).

In samtools, idxstats requires a BAM file to be sorted and indexed. Using
ParaBAM, we read the BAM file sequentially using multiple threads. Thus, we do
not require the BAM file to be sorted and indexed for normal applications using
ParaBAM.

To start the definitions line of the function, include the following:

```cpp
// [[Rcpp::export]]
int idxstats_pbam(
  std::string bam_file, 
  int n_threads_to_use = 1, 
  bool verbose = true
){
  // Add code here
}
```

Firstly, note that the "// [[Rcpp::export]]" line ensures that the function 
"idxstats_pbam" is exported as an R function when the code is compiled.

The above function will accept 3 parameters. "bam_file" is a string that takes
the path to the BAM file. "n_threads_to_use" allows the user to specify how many
threads to use. Also, "verbose" allows the user to control how much information
the function provides.

## Checking for OpenMP compatibility

As mentioned above, some systems (namely MacOS) will not be compiled with 
OpenMP. To account for this possibility, we include some code to make sure
to run the code using a single thread instead. Also, users may not know how many
threads their system has. We should also make sure we are not using more threads
than are allowed. The following code placed within "idxstats_pbam()" checks for
this:

```cpp
  unsigned int n_threads_to_really_use;
  #ifdef _OPENMP
    if(n_threads_to_use > 1) {
      if(n_threads_to_use > omp_get_max_threads()) {
        n_threads_to_really_use = omp_get_max_threads();
      } else {
        n_threads_to_really_use = n_threads_to_use;
      } 
      // omp_get_max_threads() returns the max number of threads available to OpenMP
    } else {
      n_threads_to_really_use = 1;
    }
  #else
    n_threads_to_really_use = 1;
  #endif
```

## Opening a BAM file using ParaBAM

ParaBAM uses the standard library <fstream> to read BAM files. <fstream> is
already included within the ParaBAM headers. To open a BAM file, we must open
it for binary read access as follows:

```cpp
  std::ifstream inbam_stream;   
  inbam_stream.open(bam_file, std::ios::in | std::ios::binary);
```

We must then create a "pbam_in" object to read the BAM file ans parse the
ifstream handle to this object:

```cpp
  pbam_in inbam;
  inbam.SetInputHandle(&inbam_stream, n_threads_to_really_use);
```

## Obtaining chromosome names and lengths

When the pbam_in object is parsed the ifstream handle, it will automatically
detect whether the BAM file is of a valid format, and if so, it will reader the
BAM header. To extract the chromosome names and lengths, we use the function
obtainChrs() to store this information into a string vector (s_chr_names) and
a unsigned 32-bit integer vector (u32_chr_lens):

```cpp
  std::vector<std::string> s_chr_names;
  std::vector<uint32_t> u32_chr_lens;
  int chrom_count = inbam.obtainChrs(s_chr_names, u32_chr_lens);
  // obtainChrs() returns an integer specifying the number of chromosomes
  if(chrom_count <= 0) {
    return(-1); // obtainChrs and SetInputHandle already returns relevant error msgs
  }
```

## Setting up a loop to process BAM reads sequentially

ParaBAM uses two functions, fillReads() and supplyRead(), to read BAM files and
process the reads. By default, pbam_in uses two file buffer of 200 Mb each, and
decompresses reads to fill the data buffer (1 Gb). This can be changed in the 
pbam_in constructor (see advanced features). Calling fillReads() will load two 
file buffers, and decompresses enough reads to fill the data buffer. When the
first file buffer is nearly empty, fillReads() will move the remaining 
compressed data and then uses one thread to read from the file to fill up both
buffers.

supplyRead() asks pbam_in to read its data buffer and supplies the next read.
These reads are stored in a "pbam1_t" object. We will explain the details of 
pbam1_t in a subsequent section, but for now, we can use the function 
pbam1_t::validate() to know whether the read actually contains data of a valid
BAM read. We use this function to check whether the pbam_in data buffer is
empty, because the read supplied by supplyRead() will be invalid.

Note that supplyRead() is thread-specific; i.e. each thread is allocated its own
buffer (a contiguous block of reads). The thread-specific data can be accessed
by parsing the thread number to supplyRead()

For now, this following code will read the whole BAM file from beginning to end:

```cpp
  while(0 == inbam.fillReads()) {
    #ifdef _OPENMP
    #pragma omp parallel for num_threads(n_threads_to_really_use) schedule(static,1)
    #endif
    for(unsigned int i = 0; i < n_threads_to_really_use; i++) {
      // This for loop is run concurrently for all threads from 0 to (i-1)
    
      pbam1_t read;
      read = inbam.supplyRead(i);     // Supplies the first read from thread-specific buffer i
      do {
        if(read.validate()) {
          // Process reads here
        }
        read = inbam.supplyRead(i);   // Reads the next read from thread-specific buffer
      } while(read.validate());
      // When read becomes invalid, we know we are at the end of data buffer for that thread
    }
  }
```

## Obtaining data from individual reads

To make this loop functional for identifying to which chromosome each read is
mapped, we use the function pbam1_t::refID(), which returns the refID number
from the read. We also use a vector to store our counts of the number of reads
to each chromosome, and we summate the reads coming from each buffer after the
buffer ends. See the completed code below, and compare it with the previous
block of code above (NEW denotes the code is added in this section). Note that
the integer "chrom_count" is defined above as the number of chromosomes.

```cpp
  std::vector<uint32_t> total_reads(chrom_count);   // (NEW) Stores read counts to each chromosome
  
  while(0 == inbam.fillReads()) {
    #ifdef _OPENMP
    #pragma omp parallel for num_threads(n_threads_to_really_use) schedule(static,1)
    #endif
    for(unsigned int i = 0; i < n_threads_to_really_use; i++) {
      // This for loop is run concurrently for all threads from 0 to (i-1)
      
      std::vector<uint32_t> read_counter(chrom_count);
      // (NEW) A temporary vector that stores read counts
      
      pbam1_t read;
      read = inbam.supplyRead(i);     // Supplies the first read from thread-specific buffer i
      do {
        if(read.validate()) {
          if(read.refID() >= 0) {
            read_counter.at(read.refID())++;    // (NEW) Increments read count
          }
        }
        read = inbam.supplyRead(i);   // Reads the next read from thread-specific buffer
      } while(read.validate());
      // When read becomes invalid, we know we are at the end of data buffer for that thread

      // Summarise reads (NEW):
      #ifdef _OPENMP
      #pragma omp critical
      #endif
      for(unsigned int j = 0; j < (unsigned int)chrom_count; j++) {
        total_reads.at(j) += read_counter.at(j);
      }
    }
  }
```

## Completing the idxstats function

After we are finished with the BAM file, don't forget to close the file:

```cpp
  inbam_stream.close();
```

For the output of this function, we use the function Rcout (from Rcpp) to print
out the chromosome names, lengths and read counts, just like the samtooms function
idxstats:

```cpp
  Rcout << bam_file << " summary:\n" << "Name\tLength\tNumber of reads\n";
  for(unsigned int j = 0; j < (unsigned int)chrom_count; j++) {
    Rcout << s_chr_names.at(j) << '\t' << u32_chr_lens.at(j) << '\t'
      << total_reads.at(j) << '\n';
  }
```

## Adding a progress bar

BAM files are very large files (or we wouldn't use multi-threading to read them).
Sometimes a progress bar is very useful in this regard. We show here how to use
the RcppProgress functions with ParaBAM to provide a progress bar.

pbam_in has two functions that provide data to the RcppProgress progress bar.

* pbam_in::GetFileSize() will return the file size (in bytes) of the opened BAM
file.
* pbam_in::IncProgress() will return the number of bytes processed (read and
 decompressed) since the last call to IncProgress() was made

We show how to use these two functions integrated into the example code:

```cpp
  std::vector<uint32_t> total_reads(chrom_count);   // Stores read counts to each chromosome
  
  Progress p(inbam.GetFileSize(), verbose);   // (NEW) Creates an RcppProgress progress bar
  // This progress bar has a maximum completion size equal to the file size of the BAM file
  // Set verbose = false to remove the progress bar from the user end
  
  while(0 == inbam.fillReads()) {
    p.increment(inbam.IncProgress());   
    // (NEW) Increments the progress bar by the number of bytes read / processed
    
    #ifdef _OPENMP
    #pragma omp parallel for num_threads(n_threads_to_really_use) schedule(static,1)
    #endif
    for(unsigned int i = 0; i < n_threads_to_really_use; i++) {
      // This for loop is run concurrently for all threads from 0 to (i-1)

      std::vector<uint32_t> read_counter(chrom_count);
      // A temporary vector that stores read counts
      
      pbam1_t read;
      read = inbam.supplyRead(i);     // Supplies the first read from thread-specific buffer i
      do {
        if(read.validate()) {
          if(read.refID() >= 0) {
            read_counter.at(read.refID())++;    // Increments read count
          }
        }
        read = inbam.supplyRead(i);   // Reads the next read from thread-specific buffer
      } while(read.validate());
      // When read becomes invalid, we know we are at the end of data buffer for that thread

      // Summarise reads:
      #ifdef _OPENMP
      #pragma omp critical
      #endif
      for(unsigned int j = 0; j < (unsigned int)chrom_count; j++) {
        total_reads.at(j) += read_counter.at(j);
      }
    }
  }
  p.increment(inbam.IncProgress());   // (NEW) Fills the progress bar to 100%
```

# pbam_in function documentation

## Constructor

Creates a pbam_in object

#### Usage
```cpp
pbam_in();    // Empty constructor with defaults
pbam_in(
      const size_t file_buffer_cap, 
      const size_t data_buffer_cap, 
      const unsigned int chunks_per_file_buffer
    );        // Constructor with custom settings
```


#### Parameters
* const size_t file_buffer_cap: The size (in bytes) of each of the two file buffers
* const size_t data_buffer_cap: The size (in bytes) of the data buffer containing uncompressed data
* const unsigned int chunks_per_file_buffer: How many chunks should the file buffer be divided. See details


#### Details

pbam_in reads a set amount of data from the BAM file to efficiently process 
reads. It does so using an asymmetric use of its threads. One thread is used to
read from the file, while the remaining threads decompress data already 
stored in its file buffer. In this way, we minimise the bottleneck produced
by file input.

When pbam_in::fillReads() is first called, pbam_in fills both file buffers. 
Then, it decompresses enough data from its first file buffer to fill its data 
buffer. Then, the data buffer is divided into blocks of reads to be distributed
to each thread to be retrieved via pbam_in::supplyRead().

Subsequent calls to pbam_in::fillReads() will first detect whether the first
file buffer is empty. This is defined by dividing the file buffer into chunks
(the number is defined by \code{chunks_per_file_buffer}, default 5). If the
last chunk was already partially read, pbam_in moves the file buffer data such
that the remaining data and the second buffer is now at the first buffer (and
part of the second buffer). Then it instructs one thread to continue reading
the BAM file to fill the second buffer. The remaining threads will concurrently
decompress data.

The total amount of compressed data will thus be 2 X \code{file_buffer_cap}, and
that of uncompressed data will equal \code{data_buffer_cap}. The total estimated
memory used will be \code{2 * file_buffer_cap + data_buffer_cap}.


#### Examples

```cpp
pbam_in default_pbam;                 // Creates a pbam_in object with default settings
pbam_in custom_pbam(5e8, 2e9, 10);    /* Creates a pbaam_in object with two 0.5Gb buffers,
                                         one 2 Gb data buffer, and will prompt file access
                                         when the last chunk of the first 10-chunk buffer
                                         is being decompressed.
                                      */
```


## SetInputHandle()

Assigns an ifstream handle to pbam_in. Also defines how many threads to use to
read the BAM file.


#### Usage

```cpp
int SetInputHandle(
  std::istream *in_stream, 
  const unsigned int n_threads
);
```


#### Parameters

* std::istream *in_stream: The handle of an ifstream that has opened a BAM file using input binary access
* const unsigned int n_threads: The number of threads to use to read the BAM file


#### Examples

```cpp
std::string bam_file = "example.bam";
std::ifstream inbam_stream;   
inbam_stream.open(bam_file, std::ios::in | std::ios::binary);   // Opens the BAM file for read only binary access

pbam_in inbam;
inbam.SetInputHandle(&inbam_stream, 4);    // Accesses the BAM file using 4 threads
```

## fillReads()

Reads from the BAM file, decompresses the file buffer to extract the reads.

#### Usage

```cpp
int fillReads();
```

#### Parameters

None

#### Return value

(int) Returns 0 if successful, -1 if error, and 1 if end of file is already reached.

#### Details

A loop is required to read the BAM file until finished. This can be set up by
checking the return value of fillReads() and making sure it is zero. If it is
non-zero, abort the loop as there is either an error with the file, or end
of file was reached in the last call to fillReads(). See example below.

#### Examples

```cpp
while(0 == inbam.fillReads()) {
  #ifdef _OPENMP
  #pragma omp parallel for num_threads(n_threads) schedule(static,1)
  #endif
  for(unsigned int i = 0; i < n_threads; i++) {
    pbam1_t read;
    read = inbam.supplyRead(i);
    do {
      if(read.validate()) {
        // Do stuff to read here
      }
      read = inbam.supplyRead(i);
    } while(read.validate());
  }
}
```

## supplyRead()

Reads the data buffer to supply a single aligned read from the BAM file.

#### Usage

```cpp
pbam1_t supplyRead(const unsigned int thread_number = 0);
```

#### Parameters

* const unsigned int thread_number = 0 The thread index number to retrieve the read.

#### Return value

(pbam1_t) A pbam1_t object containing the data from the aligned read.

#### Details

After fillReads() is called and the data buffer is filled, the reads are split into
equal chunks of data. Each chunk of data is processed by a single thread. This 
allows developers to set up an OpenMP for-loop such that reads from each
chunk are processed exclusively by each thread.

In the example below, notice that the #pragma omp parallel for is contained
within an #ifdef to check whether the program is compiled using OpenMP. If so,
the for loop is defined to run using OpenMP parallel for. "schedule(static,1)"
ensures only one thread is allowed to process a single iteration of this for
loop.

The thread number "i" (where i is between 0 and n_threads) is parsed into 
fillReads(). This makes sure the iteration-thread only reads contiguous reads
contained in their individual thread-specific chunk of data.

fillReads() will return a read that will not validate (using pbam1_t::validate())
when the end of the thread-specific chunk is reached.

In the example below, the while loop is set up within the parallel for loop. This
loop effectively checks to make sure each read is validated before the read is
processed further. If the read does not validate, this mean all reads from
the thread-specific chunk has been processed. 

#### Examples

```cpp
while(0 == inbam.fillReads()) {
  #ifdef _OPENMP
  #pragma omp parallel for num_threads(n_threads) schedule(static,1)
  #endif
  for(unsigned int i = 0; i < n_threads; i++) {
    pbam1_t read;
    read = inbam.supplyRead(i);
    do {
      if(read.validate()) {
        // Do stuff to read here
      }
      read = inbam.supplyRead(i);
    } while(read.validate());
  }
}
```

## obtainChrs()

Retrieves chromosome names and lengths from an opened BAM file

#### Usage

```cpp
int obtainChrs(
  std::vector<std::string> & s_chr_names, 
  std::vector<uint32_t> & u32_chr_lens
);
```

#### Parameters

* std::vector<std::string> & s_chr_names A reference to a string vector to contain chromosome names
* std::vector<uint32_t> & u32_chr_lens A reference to an uint32_t vector to contain chromosome lengths

#### Return value

(int) The number of chromosomes in the genome the BAM file is aligned to. Chromosome names and lengths
are returned to the two vectors supplied by reference.

If there is no file handle to a valid BAM file, this function will return -1.

#### Details

When a BAM file ifstream handle is parsed using SetInputHandle, pbam_in will
automatically read and store the header data, namely chromosome names and lengths.
obtainChrs() can be called to retrieve this data.

#### Examples

```cpp
std::vector<std::string> s_chr_names;   // A vector to contain chromosome names
std::vector<uint32_t> u32_chr_lens;     // A vector to contain chromosome lengths
int chrom_count = inbam.obtainChrs(s_chr_names, u32_chr_lens);
```

## Progress and File Size Functions

Returns data regarding file size, and progress

#### Usage

```cpp
size_t GetFileSize(); // Returns the file size of the BAM file
size_t GetProgress(); // Returns the total number of bytes processed (read and decompressed)
size_t IncProgress(); // Returns the number of bytes processed since the last call to IncProgress()
```

#### Return value

See above

#### Details

When a BAM file ifstream handle is parsed using SetInputHandle, pbam_in will
automatically read and store the header data, namely chromosome names and lengths.
obtainChrs() can be called to retrieve this data.

#### Examples

```cpp
size_t file_size = inbam.GetFileSize();
size_t bytes_read = inbam.GetProgress();

inbam.fillReads();
size_t bytes_read_total = inbam.GetProgress();
size_t bytes_read_since_last_asked = inbam.IncProgress();
```
